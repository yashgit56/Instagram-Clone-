/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var align = __webpack_require__(1)
	var demo = document.getElementById('demo')
	var menu = document.getElementById('menu')
	setPosition()
	
	function setPosition() {
	  var vf = document.getElementById('from').value
	  var vt = document.getElementById('to').value
	  align(demo, menu, vf + '-' + vt)
	}
	document.getElementById('from').addEventListener('change', function () {
	  setPosition()
	})
	document.getElementById('to').addEventListener('change', function () {
	  setPosition()
	})


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var computedStyle = __webpack_require__(2)
	var doc = document.documentElement
	
	/**
	 * align from to to element with position
	 *
	 * @public
	 * @param {Element} from
	 * @param {Element} to
	 * @param {Object} offset
	 * @param {String} position
	 */
	function align(from, to, position, offset) {
	  if (!/[tlrbc]{2}-[tlrbc]{2}/.test(position)) throw new Error('invalid position ' + position)
	  var pel = getRelativeElement(from)
	  if (pel !== getRelativeElement(to)) throw new Error('from and to should share same position element')
	  var pos = getAbsolutePosition(from, pel)
	  var parts = position.split('-')
	  var point = getFromPoint(pos, parts[0])
	  var res = getPosition(to, point, parts[1])
	  if (offset) {
	      res.x += offset.x || 0
	      res.y += offset.y || 0
	  }
	  to.style.top = res.y + 'px'
	  to.style.left = res.x + 'px'
	}
	
	function getPosition(to, point, str) {
	  var x = point.x
	  var y = point.y
	  var th = parseInt(computedStyle(to, 'height'), 10)
	  var tw = parseInt(computedStyle(to, 'width'), 10)
	  if (isNaN(th) || isNaN(tw)) throw new Error('can\'t get dimension of to element')
	  if (~str.indexOf('b')) {
	    y = y - th
	  }
	  if (~str.indexOf('r')) {
	    x = x - tw
	  }
	  if (~str.indexOf('c')) {
	    switch (str.replace('c', '')) {
	      case 't':
	        x = x - tw/2
	        break
	      case 'b':
	        x = x - tw/2
	        break
	      case 'l':
	        y = y - th/2
	        break
	      case 'r':
	        y = y - th/2
	        break
	    }
	  }
	  return {x:x, y:y}
	}
	
	function getFromPoint(pos, str) {
	  var x = pos.left
	  var y = pos.top
	  if (~str.indexOf('b')) {
	    y = y + pos.height
	  }
	  if (~str.indexOf('r')) {
	    x = x + pos.width
	  }
	  if (~str.indexOf('c')) {
	    switch (str.replace('c', '')) {
	      case 't':
	        x = x + pos.width/2
	        break
	      case 'b':
	        x = x + pos.width/2
	        break
	      case 'l':
	        y = y + pos.height/2
	        break
	      case 'r':
	        y = y + pos.height/2
	        break
	    }
	  }
	  return {x: x, y:y}
	}
	
	function getRelativeElement (el) {
	  do {
	    el = el.parentNode
	    if (el === doc) return el
	    var p = getComputedStyle(el).position
	    if (p === 'absolute' || p === 'fixed' || p === 'relative') {
	      return el
	    }
	  } while(el)
	}
	
	/**
	 * Get absolute left top width height
	 *
	 * @param  {Element}  el
	 * @param {Element} pel
	 * @return {Object}
	 * @api public
	 */
	function getAbsolutePosition (el, pel) {
	  var r = el.getBoundingClientRect()
	  var rect = pel.getBoundingClientRect()
	  return {
	    left: r.left - rect.left,
	    top: r.top -rect.top,
	    width: r.width,
	    height: r.height
	  }
	}
	
	module.exports = align


/***/ },
/* 2 */
/***/ function(module, exports) {

	// DEV: We don't use var but favor parameters since these play nicer with minification
	function computedStyle(el, prop, getComputedStyle, style) {
	  getComputedStyle = window.getComputedStyle;
	  style =
	      // If we have getComputedStyle
	      getComputedStyle ?
	        // Query it
	        // TODO: From CSS-Query notes, we might need (node, null) for FF
	        getComputedStyle(el) :
	
	      // Otherwise, we are in IE and use currentStyle
	        el.currentStyle;
	  if (style) {
	    return style
	    [
	      // Switch to camelCase for CSSOM
	      // DEV: Grabbed from jQuery
	      // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
	      // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
	      prop.replace(/-(\w)/gi, function (word, letter) {
	        return letter.toUpperCase();
	      })
	    ];
	  }
	}
	
	module.exports = computedStyle;


/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map